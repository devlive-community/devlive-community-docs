[TOC]

### countBy

---------------------------------------------------------------------------------------------------------------------

`(a → String) → [a] → {*}`

Parameters

*   fnThe function used to map values to keys.
*   listThe list to count elements from.

> Returns Object An object mapping keys to number of occurrences in the list.

Added in v0.1.0

Counts the elements of a list according to how many match each value of a key generated by the supplied function. Returns an object mapping the keys produced by `fn` to the number of occurrences in the list. Note that all keys are coerced to strings because of how JavaScript objects work.

Acts as a transducer if a transformer is given in list position.

```js
const numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}

const letters = ['a', 'b', 'A', 'a', 'B', 'c'];
R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
```

### difference

------------------------------------------------------------------------------------------------------------------------------

`[*] → [*] → [*]`

Parameters

*   list1The first list.
*   list2The second list.

> Returns Array The elements in `list1` that are not in `list2`.

Added in v0.1.0

Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list. Objects and Arrays are compared in terms of value equality, not reference equality.

See also [differenceWith](#differenceWith), [symmetricDifference](#symmetricDifference), [symmetricDifferenceWith](#symmetricDifferenceWith), [without](#without).

```js
R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
```

### differenceWith

------------------------------------------------------------------------------------------------------------------------------------------

`((a, a) → Boolean) → [a] → [a] → [a]`

Parameters

*   predA predicate used to test whether two items are equal.

*   list1The first list.
*   list2The second list.

> Returns Array The elements in \`list1\` that are not in `list2`.

Added in v0.1.0

Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list. Duplication is determined according to the value returned by applying the supplied predicate to two list elements.

See also [difference](#difference), [symmetricDifference](#symmetricDifference), [symmetricDifferenceWith](#symmetricDifferenceWith).

```js
const cmp = (x, y) => x.a === y.a;
const l1 = [{a: 1}, {a: 2}, {a: 3}];
const l2 = [{a: 3}, {a: 4}];
R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]

R.differenceWith(R.equals, [1, 2, 3, 3, 3], []); //=> [1, 2, 3]
R.differenceWith(R.equals, [1, 2, 3, 3, 3], [1]); //=> [2, 3]
```

### unionWith

---------------------------------------------------------------------------------------------------------------------------

`((a, a) → Boolean) → [*] → [*] → [*]`

Parameters

*   predA predicate used to test whether two items are equal.
*   list1The first list.
*   list2The second list.

> Returns Array The first and second lists concatenated, with duplicates removed.

Added in v0.1.0

Combines two lists into a set (i.e. no duplicates) composed of the elements of each list. Duplication is determined according to the value returned by applying the supplied predicate to two list elements. If an element exists in both lists, the first element from the first list will be used.

See also [union](#union).

```js
const l1 = [{a: 1}, {a: 2}];
const l2 = [{a: 1}, {a: 4}];
R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
```

### union

---------------------------------------------------------------------------------------------------------------

`[*] → [*] → [*]`

Parameters

*   asThe first list.
*   bsThe second list.

> Returns Array The first and second lists concatenated, with duplicates removed.

Added in v0.1.0

Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.

```js
R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
```

### gt

------------------------------------------------------------------------------------------------------

`Ord a => a → a → Boolean`

Added in v0.1.0

Returns `true` if the first argument is greater than the second; `false` otherwise.

See also [lt](#lt).

```js
R.gt(2, 1); //=> true
R.gt(2, 2); //=> false
R.gt(2, 3); //=> false
R.gt('a', 'z'); //=> false
R.gt('z', 'a'); //=> true
```

### gte

---------------------------------------------------------------------------------------------------------

`Ord a => a → a → Boolean`

Added in v0.1.0

Returns `true` if the first argument is greater than or equal to the second; `false` otherwise.

See also [lte](#lte).

```js
R.gte(2, 1); //=> true
R.gte(2, 2); //=> true
R.gte(2, 3); //=> false
R.gte('a', 'z'); //=> false
R.gte('z', 'a'); //=> true
```

### intersection

------------------------------------------------------------------------------------------------------------------------------------

`[*] → [*] → [*]`

Parameters

*   list1The first list.
*   list2The second list.

> Returns Array The list of elements found in both `list1` and `list2`.

Added in v0.1.0

Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.

See also [innerJoin](#innerJoin).

```js
R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
```

### lt

------------------------------------------------------------------------------------------------------

`Ord a => a → a → Boolean`

Added in v0.1.0

Returns `true` if the first argument is less than the second; `false` otherwise.

See also [gt](#gt).

```js
R.lt(2, 1); //=> false
R.lt(2, 2); //=> false
R.lt(2, 3); //=> true
R.lt('a', 'z'); //=> true
R.lt('z', 'a'); //=> false
```

### lte

---------------------------------------------------------------------------------------------------------

`Ord a => a → a → Boolean`

Added in v0.1.0

Returns `true` if the first argument is less than or equal to the second; `false` otherwise.

See also [gte](#gte).

```js
R.lte(2, 1); //=> false
R.lte(2, 2); //=> true
R.lte(2, 3); //=> true
R.lte('a', 'z'); //=> true
R.lte('z', 'a'); //=> false
```

### max

---------------------------------------------------------------------------------------------------------

`Ord a => a → a → a`

Added in v0.1.0

Returns the larger of its two arguments.

See also [maxBy](#maxBy), [min](#min).

```js
R.max(789, 123); //=> 789
R.max('a', 'b'); //=> 'b'
```

### min

---------------------------------------------------------------------------------------------------------

`Ord a => a → a → a`

Added in v0.1.0

Returns the smaller of its two arguments.

See also [minBy](#minBy), [max](#max).

```js
R.min(789, 123); //=> 123
R.min('a', 'b'); //=> 'a'
```

### propEq

---

`a → String → Object → Boolean`

Parameters

*   valThe value to compare the property with
*   namethe specified object property's key
*   objThe object to check the property in

> Returns Boolean `true` if the value equals the specified object property, `false` otherwise.

Added in v0.1.0

Returns `true` if the specified object property is equal, in [`R.equals`](#equals) terms, to the given value; `false` otherwise. You can test multiple properties with [`R.whereEq`](#whereEq), and test nested path property with [`R.pathEq`](#pathEq).

See also [whereEq](#whereEq), [pathEq](#pathEq), [propSatisfies](#propSatisfies), [equals](#equals).

```js
const abby = {name: 'Abby', age: 7, hair: 'blond'};
const fred = {name: 'Fred', age: 12, hair: 'brown'};
const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
const alois = {name: 'Alois', age: 15, disposition: 'surly'};
const kids = [abby, fred, rusty, alois];
const hasBrownHair = R.propEq('brown', 'hair');
R.filter(hasBrownHair, kids); //=> [fred, rusty]
```

### sortBy

---

`Ord b => (a → b) → [a] → [a]`

Parameters

*   fn
*   listThe list to sort.

> Returns Array A new list sorted by the keys generated by `fn`.

Added in v0.1.0

Sorts the list according to the supplied function.

```js
const sortByFirstItem = R.sortBy(R.prop(0));
const pairs = [[-1, 1], [-2, 2], [-3, 3]];
sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]

const sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
const alice = {
  name: 'ALICE',
  age: 101
};
const bob = {
  name: 'Bob',
  age: -10
};
const clara = {
  name: 'clara',
  age: 314.159
};
const people = [clara, bob, alice];
sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
```

### pathEq

---

`a → [Idx] → {a} → Boolean`

`Idx = String | Int | Symbol`

Parameters

*   valThe value to compare the nested property with
*   pathThe path of the nested property to use
*   objThe object to check the nested property in

> Returns Boolean `true` if the value equals the nested object property, `false` otherwise.

Added in v0.7.0

Determines whether a nested path on an object has a specific value, in [`R.equals`](#equals) terms. Most likely used to filter a list.

See also [whereEq](#whereEq), [propEq](#propEq), [pathSatisfies](#pathSatisfies), [equals](#equals).

```js
const user1 = { address: { zipCode: 90210 } };
const user2 = { address: { zipCode: 55555 } };
const user3 = { name: 'Bob' };
const users = [ user1, user2, user3 ];
const isFamous = R.pathEq(90210, ['address', 'zipCode']);
R.filter(isFamous, users); //=> [ user1 ]
```

### maxBy

---

`Ord b => (a → b) → a → a → a`

Added in v0.8.0

Takes a function and two values, and returns whichever value produces the larger result when passed to the provided function.

See also [max](#max), [minBy](#minBy).

```js
//  square :: Number -> Number
const square = n => n * n;

R.maxBy(square, -3, 2); //=> -3

R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
R.reduce(R.maxBy(square), 0, []); //=> 0
```

### minBy

---

`Ord b => (a → b) → a → a → a`

Added in v0.8.0

Takes a function and two values, and returns whichever value produces the smaller result when passed to the provided function.

See also [min](#min), [maxBy](#maxBy).

```js
//  square :: Number -> Number
const square = n => n * n;

R.minBy(square, -3, 2); //=> 2

R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
R.reduce(R.minBy(square), Infinity, []); //=> Infinity
```

### equals

---

`a → b → Boolean`

Added in v0.15.0

Returns `true` if its arguments are equivalent, `false` otherwise. Handles cyclical data structures.

Dispatches symmetrically to the `equals` methods of both arguments, if present.

```js
R.equals(1, 1); //=> true
R.equals(1, '1'); //=> false
R.equals([1, 2, 3], [1, 2, 3]); //=> true

const a = {}; a.v = a;
const b = {}; b.v = b;
R.equals(a, b); //=> true
```

### identical

---

`a → a → Boolean`

Added in v0.15.0

Returns true if its arguments are identical, false otherwise. Values are identical if they reference the same memory. `NaN` is identical to `NaN`; `0` and `-0` are not identical.

Note this is merely a curried version of ES6 `Object.is`.

`identical` does not support the `__` placeholder.

```js
const o = {};
R.identical(o, o); //=> true
R.identical(1, 1); //=> true
R.identical(1, '1'); //=> false
R.identical([], []); //=> false
R.identical(0, -0); //=> false
R.identical(NaN, NaN); //=> true
```

### eqBy

---

`(a → b) → a → a → Boolean`

Added in v0.18.0

Takes a function and two values in its domain and returns `true` if the values map to the same value in the codomain; `false` otherwise.

```js
R.eqBy(Math.abs, 5, -5); //=> true
```

### clamp

---

`Ord a => a → a → a → a`

Parameters

*   minimumThe lower limit of the clamp (inclusive)
*   maximumThe upper limit of the clamp (inclusive)
*   valueValue to be clamped

> Returns Number Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise

Added in v0.20.0

Restricts a number to be within a range.

Also works for other ordered types such as Strings and Dates.

```js
R.clamp(1, 10, -5) // => 1
R.clamp(1, 10, 15) // => 10
R.clamp(1, 10, 4)  // => 4
```
